#' Evaluate Watershed 
#' 
#' Train model on non-N2 pairs and evaluate model on held-out N2-pairs. 
#' This allows the user to get an idea of the accuracy of Watershed applied to their data.
#'
#' @param input_file String corresponding to the file name of the Watershed input file.
#'   Either a file path or a URL. See details for required format. 
#' @param model_name String identifier corresponding to the model to use. 
#'   Options are "RIVER", "Watershed_exact", and "Watershed_approximate"
#' @param number_of_dimensions Integer representing the number of outlier types. 
#'   Sometimes referred to as \code{E} in our documentation.  
#' @param dirichlet_prior Float parameter defining Dirichlet distribution that acts 
#'   as a prior a Phi (the model parameters defining E|Z)
#' @param l2_prior_parameter Float defining the L2 (gaussian) distribution that acts 
#'   as a prior on the parameters defining the conditional random field P(Z|G). 
#'   If set to NULL, Watershed will run a grid search on held-out data to select an 
#'   optimal L2 prior. We recommend setting this parameter to NULL. Default: NULL
#' @param output_prefix String corresponding to the prefix of all output files generated by this function
#' @param n2_pair_pvalue_fraction Float. Fraction of outliers (based on rank) that are 
#'   considered an outlier for N2 pair analysis (this is done so each outlier type/signal 
#'   has approximately the same distribution of positive outlier examples). Default: 0.1
#' @param binary_pvalue_threshold Float. Absolute p-value threshold used to create 
#'   binary outliers used for Genomic Annotation Model. Default: 0.1
#' @param lambda_costs Numeric vector of length 3. If \code{l2_prior_parameter} is NULL, 
#'   perform grid search over the following values of lambda to determine optimal lambda.
#'   Default: \code{c(.1, .01, 1e-3)}
#' @param nfolds Integer. If \code{l2_prior_parameter} is NULL, Number of folds 
#'   to be used in K-fold cross validation for Genomic annotation model. Default: 5
#' @param vi_step_size Float. Parameter used for Variational Optimization. 
#'   Only applies if \code{model_name == "Watershed_approximate"}. Default: 0.8
#' @param vi_threshold Float. Parameter used for Variational Optimization. 
#'   Only applies if \code{model_name == "Watershed_approximate"}. Default: 1e-8
#'
#' @return 
#' A named list:
#' \itemize{
#'   \item{\code{model_params}}{contains all of the optimized Watershed parameters}
#'   \item{\code{gam_model_params}}{contains all optimized GAM parameters}
#'   \item{\code{auc}}{contains information on evaluation (precion-recall stats, etc)}
#'     \itemize{
#'       \item{\code{auc[[1]]$evaROC$watershed_pr_auc}}{gives the area under the precision recall curve 
#'         (for Watershed/RIVER) in the first outlier dimension (base 1)}
#'       \item{\code{auc[[3]]$evaROC$watershed_pr_auc}}{gives the area under the precision recall curve 
#'         (for Watershed/RIVER) in the third outlier dimension (base 1)}
#'       \item{\code{auc[[1]]$evaROC$GAM_pr_auc}}{gives the area under the precision recall curve 
#'         (for GAM) in the first outlier dimension (base 1)}
#'       \item{\code{auc[[1]]$evaROC$watershed_precision}}{gives a vector of precision values 
#'         (for Watershed/RIVER) in the first outlier dimension (base 1). The vector 
#'         spans posterior thresholds generated by the R library "PRROC"}
#'       \item{\code{auc[[1]]$evaROC$watershed_recall}}{gives a vector of recall values (for Watershed/RIVER) 
#'         in the first outlier dimension (base 1). This vector is the same length as precision vector above 
#'         (and can be therefor used together to make a PR-curve). 
#'         The vector spans posterior thresholds generated by the R library "PRROC"}
#'       \item{\code{auc[[1]]$evaROC$GAM_precision}}{gives a vector of precision values (for GAM) 
#'         in the first outlier dimension (base 1). The vector spans posterior 
#'         thresholds generated by the R library "PRROC"}
#'       \item{\code{auc[[1]]$evaROC$GAM_recall}}{gives a vector of recall values 
#'         (for GAM) in the first outlier dimension (base 1). This vector is the same 
#'         length as precision vector above (and can be therefor used together to make a PR-curve). 
#'         The vector spans posterior thresholds generated by the R library "PRROC"}
#'     }
#' }
#' 
#' @export
#'
#' @examples
#' \dontrun{
#' # For all examples, use example data that has 3 E outlier p-value columns, 
#' # which corresponds to number_of_dimensions = 3
#' input = paste0("https://raw.githubusercontent.com/BennyStrobes/Watershed/",
#'      "master/example_data/watershed_example_data.txt")
#' 
#' # Run using Watershed approximate inference
#' evaluate_watershed(input_file = input,
#'                    model_name = "Watershed_approximate", 
#'                    number_of_dimensions = 3,
#'                    output_prefix = "watershed_approximate_n3")
#' 
#' # Run using Watershed exact inference
#' evaluate_watershed(input_file = input, 
#'                    model_name = "Watershed_exact", 
#'                    number_of_dimensions = 3,
#'                    output_prefix = "watershed_exact_n3")
#' 
#' # Run using RIVER
#' evaluate_watershed(input_file = input, 
#'                    model_name = "RIVER", 
#'                    number_of_dimensions = 3,
#'                    output_prefix = "river_n3")
#' }
#' 
#' @details 
#' "Watershed_exact" is Watershed where parameters are optimized via exact inference 
#' (tractable and recommended when the number of dimensions (E) is small. 
#' A general rule of thumb is if the number of dimensions (E) is less than equal to 4, 
#' exact inference should be used). "Watershed_approximate" is Watershed where parameters 
#' are optimized using approximate inference. This approach is tractable when the 
#' number of dimensions (E) is large.
#' 
#' Watershed models instances of gene-individual pairs. Therefore each line in the 
#' Watershed input file must be a gene-individual pair. Each line must include a 
#' minimum of one genomic annotation describing the rare variants nearby the gene 
#' for that individual. Each line must also include a minimum of one outlier score 
#' (p-value) describing the gene-individual pair. To evaluate Watershed performance 
#' we rely on N2 pairs, or pairs of individuals that share the same rare genetic 
#' variant nearby a particular gene (see \href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7646251/}{the publication} for more details). 
#' Therefore, each line in the input file must contain a column concerning whether 
#' the gene-individual is an N2 pair. If the gene-individual is not an N2 pair, 
#' it can be represented as "NA". If the gene-individual is in an N2 pair, it can 
#' be represented as a positive integer that represents the unique identifier for 
#' that N2 pair. 
#' 
#' Note: if there are more than two individuals with the same rare 
#' genetic variant, you must randomly select two individuals and ignore all other 
#' individuals.
#' 
#' More formally, assuming G genomic annotations and E outlier p-values, the columns 
#' of the Watershed input file are as follows (column ordering is essential):
#' \describe{
#'   \item{\code{SubjectID}}{Identifier for the individual in the gene-individual pair}
#'   \item{\code{GeneName}}{Identifier for the gene in the gene-individual pair}
#'   \item{\code{\[Genomic Annotation\]}}{A column for each of the G genomic annotations. 
#'     Header names of these columns can be entirely user specified. Values are real valued.}
#'   \item{\code{\[E outlier p-values\]}}{A column for each of the E outlier p-values. 
#'     Header names of these columns can be entirely user specified. Values are p-values (i.e., \[0,1\]). 
#'     It is okay to have missing/unobserved values. If an outlier is missing for a gene-individual pair, 
#'     use "NaN" for that element.}
#'   \item{\code{N2pair}}{Identifier for whether gene-individual is in an N2 pair. 
#'     If it is not, use "NA". If it is an N2 pair, use a unique positive integer to identify the pair.}
#' }
#' 
evaluate_watershed <- function(input_file, 
                               model_name, 
                               number_of_dimensions = 1, 
                               dirichlet_prior = 10, 
                               l2_prior_parameter = NULL, 
                               output_prefix = "watershed", 
                               n2_pair_pvalue_fraction = 0.1, 
                               binary_pvalue_threshold = 0.1, 
                               lambda_costs = c(.1, .01, 1e-3), 
                               nfolds = 5, 
                               vi_step_size = 0.8, 
                               vi_threshold = 1e-8){
  
  # make argument names match
  pseudoc <- dirichlet_prior
  lambda_init <- l2_prior_parameter
  output_stem <- output_prefix 
  
  ### check arguments 
  model_name <- tolower(model_name)
  if(!model_name %in% c("river","watershed_exact","watershed_approximate")){
    stop("Model name must be one of 'RIVER', 'Watershed_exact', 'Watershed_approximate'.")
  }
  
  # Change model to RIVER if there is only 1 dimension.
  if (number_of_dimensions == 1 & model_name != "river"){
    warning("Only RIVER can be run on data with 1 dimension.\n Changing model to RIVER.")
    model_name <- "river"
  }
  
  ########################
  ## Load in data
  ########################
  data_input <- load_watershed_data(input_file, number_of_dimensions, n2_pair_pvalue_fraction, binary_pvalue_threshold)
  # Parse data_input for evaluation-related relevant fields
  feat_all <- data_input$feat
  discrete_outliers_all <- data_input$outliers_discrete
  binary_outliers_all <- data_input$outliers_binary
  fraction_binary_outliers_all <- data_input$fraction_outliers_binary
  N2_pairs <- data_input$N2_pairs
  
  ## Extract training data (ie. non-N2-pairs)
  feat_train <- feat_all[is.na(N2_pairs),]
  discrete_outliers_train <- as.matrix(discrete_outliers_all[is.na(N2_pairs),])
  binary_outliers_train <-  as.matrix(binary_outliers_all[is.na(N2_pairs),])
  
  ## Extract test data (ie N2 pairs)
  #(has to be done seperately for RIVER vs Watershed)
  if (number_of_dimensions == 1) {
    # Extraction of test data for RIVER
    feat_test <- rbind(feat_all[!is.na(N2_pairs),][seq(from=1,to=sum(!is.na(N2_pairs)),by=2),], feat_all[!is.na(N2_pairs),][seq(from=2,to=sum(!is.na(N2_pairs)),by=2),])
    discrete_outliers_test1 <- as.matrix(c(discrete_outliers_all[!is.na(N2_pairs)][seq(from=1,to=sum(!is.na(N2_pairs)),by=2)], discrete_outliers_all[!is.na(N2_pairs)][seq(from=2,to=sum(!is.na(N2_pairs)),by=2)]))
    discrete_outliers_test2 <- as.matrix(c(discrete_outliers_all[!is.na(N2_pairs)][seq(from=2,to=sum(!is.na(N2_pairs)),by=2)], discrete_outliers_all[!is.na(N2_pairs)][seq(from=1,to=sum(!is.na(N2_pairs)),by=2)]))
    binary_outliers_test1 <- as.matrix(c(binary_outliers_all[!is.na(N2_pairs)][seq(from=1,to=sum(!is.na(N2_pairs)),by=2)], binary_outliers_all[!is.na(N2_pairs)][seq(from=2,to=sum(!is.na(N2_pairs)),by=2)]))
    binary_outliers_test2 <- as.matrix(c(fraction_binary_outliers_all[!is.na(N2_pairs)][seq(from=2,to=sum(!is.na(N2_pairs)),by=2)], fraction_binary_outliers_all[!is.na(N2_pairs)][seq(from=1,to=sum(!is.na(N2_pairs)),by=2)]))
    # Absolute pvalues from test prediction data set (to be used for RNA-only analysis)
    real_valued_outliers_test1 <- -log10(abs(as.matrix(c(data_input$outlier_pvalues[!is.na(N2_pairs)][seq(from=1,to=sum(!is.na(N2_pairs)),by=2)], data_input$outlier_pvalues[!is.na(N2_pairs)][seq(from=2,to=sum(!is.na(N2_pairs)),by=2)]))) + 1e-7)
    
  } else {
    # Extraction of test data for Watershed
    feat_test <- rbind(feat_all[!is.na(N2_pairs),][seq(from=1,to=sum(!is.na(N2_pairs)),by=2),], feat_all[!is.na(N2_pairs),][seq(from=2,to=sum(!is.na(N2_pairs)),by=2),])
    discrete_outliers_test1 <- rbind(discrete_outliers_all[!is.na(N2_pairs),][seq(from=1,to=sum(!is.na(N2_pairs)),by=2),], discrete_outliers_all[!is.na(N2_pairs),][seq(from=2,to=sum(!is.na(N2_pairs)),by=2),])
    discrete_outliers_test2 <- rbind(discrete_outliers_all[!is.na(N2_pairs),][seq(from=2,to=sum(!is.na(N2_pairs)),by=2),], discrete_outliers_all[!is.na(N2_pairs),][seq(from=1,to=sum(!is.na(N2_pairs)),by=2),])
    binary_outliers_test1 <- rbind(binary_outliers_all[!is.na(N2_pairs),][seq(from=1,to=sum(!is.na(N2_pairs)),by=2),], binary_outliers_all[!is.na(N2_pairs),][seq(from=2,to=sum(!is.na(N2_pairs)),by=2),])
    binary_outliers_test2 <- rbind(fraction_binary_outliers_all[!is.na(N2_pairs),][seq(from=2,to=sum(!is.na(N2_pairs)),by=2),], fraction_binary_outliers_all[!is.na(N2_pairs),][seq(from=1,to=sum(!is.na(N2_pairs)),by=2),])
    # Absolute pvalues from test prediction data set (to be used for RNA-only analysis)
    real_valued_outliers_test1 <- -log10(abs(rbind(data_input$outlier_pvalues[!is.na(N2_pairs),][seq(from=1,to=sum(!is.na(N2_pairs)),by=2),], data_input$outlier_pvalues[!is.na(N2_pairs),][seq(from=2,to=sum(!is.na(N2_pairs)),by=2),])) + 1e-7)
  }
  
  #######################################
  ## Standardize Genomic Annotations (features)
  #######################################
  mean_feat <- apply(feat_all, 2, mean)
  sd_feat <- apply(feat_all, 2, sd)
  feat_all <- scale(feat_all, center=mean_feat, scale=sd_feat)
  feat_train <- scale(feat_train, center=mean_feat, scale=sd_feat)
  feat_test <- scale(feat_test, center=mean_feat, scale=sd_feat)
  
  #######################################
  ## Fit Genomic Annotation Model (GAM)
  #######################################
  gam_data <- logistic_regression_genomic_annotation_model_cv(feat_train, binary_outliers_train, nfolds, lambda_costs, lambda_init)
  # Report optimal lambda learned from cross-validation data (if applicable)
  if (is.null(lambda_init)) {
    message(paste0(nfolds,"-fold cross validation on GAM yielded optimal lambda of ", gam_data$lambda))
  }
  # Compute GAM Predictions on test data in CPP file ("independent_crf_exact_updates.cpp")
  gam_posterior_test_obj <- update_independent_marginal_probabilities_exact_inference_cpp(feat_test, binary_outliers_test1, gam_data$gam_parameters$theta_singleton, gam_data$gam_parameters$theta_pair, gam_data$gam_parameters$theta, matrix(0,2,2), matrix(0,2,2), number_of_dimensions, choose(number_of_dimensions, 2), FALSE)
  gam_test_posteriors <- gam_posterior_test_obj$probability
  
  #######################################
  ### Initialize phi using GAM
  #######################################
  # Compute GAM Predictions on training data in CPP file ("independent_crf_exact_updates.cpp")
  gam_posterior_train_obj <- update_independent_marginal_probabilities_exact_inference_cpp(feat_train, 
                                                                                           binary_outliers_test1, 
                                                                                           gam_data$gam_parameters$theta_singleton, 
                                                                                           gam_data$gam_parameters$theta_pair, 
                                                                                           gam_data$gam_parameters$theta, 
                                                                                           matrix(0,2,2), 
                                                                                           matrix(0,2,2), 
                                                                                           number_of_dimensions, 
                                                                                           choose(number_of_dimensions, 2), 
                                                                                           FALSE)
  gam_train_posteriors <- gam_posterior_train_obj$probability
  # Initialize Phi using GAM posteriors
  # ie. Compute MAP estimates of the coefficients defined by P(outlier_status| FR)
  phi_init <- map_phi_initialization(discrete_outliers_train, gam_train_posteriors, number_of_dimensions, pseudoc)
  
  #######################################
  ### Fit Watershed Model
  #######################################
  watershed_model <- train_watershed_model(feat_train, 
                                           discrete_outliers_train, 
                                           phi_init, 
                                           gam_data$gam_parameters$theta_pair, 
                                           gam_data$gam_parameters$theta_singleton, 
                                           gam_data$gam_parameters$theta, 
                                           pseudoc, 
                                           gam_data$lambda, 
                                           number_of_dimensions, 
                                           model_name, 
                                           vi_step_size, 
                                           vi_threshold)
  
  #######################################
  ## Compute Watershed Posterior probabilities for held-out test data (ie the N2 pairs)
  #######################################
  posterior_info_test <- update_marginal_posterior_probabilities(feat_test, discrete_outliers_test1, watershed_model)
  posterior_prob_test <- posterior_info_test$probability  # Marginal posteriors
  posterior_pairwise_prob_test <- posterior_info_test$probability_pairwise  # Pairwise posteriors
  
  #######################################
  # Extract precision recall curves for test set (in each dimension seperately) using:
  #### 1. Watershed predictions
  #### 2. GAM predictions
  #######################################
  auc_object_across_dimensions <- compute_auc_across_dimensions(number_of_dimensions, 
                                                                posterior_prob_test, 
                                                                gam_test_posteriors, 
                                                                real_valued_outliers_test1, 
                                                                binary_outliers_test2)
  
  evaluation_object <- list(auc=auc_object_across_dimensions, 
                            model_params=watershed_model, 
                            gam_model_params=gam_data)
  
  #######################################
  ## Save evaluation object as .rds file
  #######################################
  saveRDS(evaluation_object, paste0(output_stem, "_evaluation_object.rds"))
  
  #######################################
  ## Print area under precision-recall curves in each dimension
  #######################################
  for (dimension in 1:number_of_dimensions) {
    model_pr_auc <- evaluation_object$auc[[dimension]]$evaROC$watershed_pr_auc
    gam_pr_auc <- evaluation_object$auc[[dimension]]$evaROC$GAM_pr_auc
    message(paste0(model_name, " area under precision-recall curve in dimension ", dimension,": ", model_pr_auc))
    message(paste0("GAM area under precision-recall curve in dimension ", dimension,": ", gam_pr_auc))
  }
  
  return(evaluation_object)
}


#######################################
# Extract precision recall curves for test set (in each dimension separately) using:
#### 1. Watershed predictions
#### 2. GAM predictions
#######################################
compute_auc_across_dimensions <- function(number_of_dimensions, 
                                          watershed_posteriors, 
                                          gam_posteriors, 
                                          real_valued_outliers_test1, 
                                          binary_outliers_test2) {
	# Initialize objects to store auc information
	auc_object_across_dimensions <- list()
	pos_list <- c()
	neg_list <- c()
	# Loop through dimensions
	for (dimension in 1:number_of_dimensions) {
		# Pseudo gold standard
		test_outlier_status <- binary_outliers_test2[,dimension]

	  # Watershed evaluation curves
		watershed_roc_obj <- roc.curve(scores.class0 = na.omit(watershed_posteriors[,dimension][test_outlier_status==1 & !is.na(real_valued_outliers_test1[,dimension])]), scores.class1 = na.omit(watershed_posteriors[,dimension][test_outlier_status==0 & !is.na(real_valued_outliers_test1[,dimension])]), curve = T)
		watershed_pr_obj <- pr.curve(scores.class0 = na.omit(watershed_posteriors[,dimension][test_outlier_status==1 & !is.na(real_valued_outliers_test1[,dimension])]), scores.class1 = na.omit(watershed_posteriors[,dimension][test_outlier_status==0 & !is.na(real_valued_outliers_test1[,dimension])]), curve = T)
	
		# GAM evaluation curves
		gam_roc_obj <- roc.curve(scores.class0 = na.omit(gam_posteriors[,dimension][test_outlier_status==1 & !is.na(real_valued_outliers_test1[,dimension])]), scores.class1 = na.omit(gam_posteriors[,dimension][test_outlier_status==0 & !is.na(real_valued_outliers_test1[,dimension])]), curve = T)
 		gam_pr_obj <- pr.curve(scores.class0 = na.omit(gam_posteriors[,dimension][test_outlier_status==1 & !is.na(real_valued_outliers_test1[,dimension])]), scores.class1 = na.omit(gam_posteriors[,dimension][test_outlier_status==0 & !is.na(real_valued_outliers_test1[,dimension])]), curve = T)

		evaROC <-	
		  list(watershed_sens=watershed_roc_obj$curve[,2],
		      watershed_spec=1-watershed_roc_obj$curve[,1],
         	watershed_auc=watershed_roc_obj$auc,
         	watershed_pr_auc=watershed_pr_obj$auc.integral,
         	watershed_recall=watershed_pr_obj$curve[,1],
         	watershed_precision=watershed_pr_obj$curve[,2],
         	GAM_sens=gam_roc_obj$curve[,2],
          GAM_spec=1-gam_roc_obj$curve[,1],
          GAM_auc=gam_roc_obj$auc,
         	GAM_pr_auc=gam_pr_obj$auc.integral,
         	GAM_recall=gam_pr_obj$curve[,1],
         	GAM_precision=gam_pr_obj$curve[,2])

		auc_object_across_dimensions[[dimension]] <- list(evaROC=evaROC)
	}

	return(auc_object_across_dimensions)
}

